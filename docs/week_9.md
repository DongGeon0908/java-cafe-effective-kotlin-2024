# week_9.md

<hr>

### 진행내용

- 아이템 36: 상속보다는 컴포지션을 사용하라
- 아이템 37: 데이터 집합 표현에 data 한정자를 사용하라
- 아이템 38: 연산 또는 액션을 전달할 때 인터페이스 대신 함수 타입을 사용하라
- 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라

<br>
<br>
<hr>
<br>
<br>

### [아이템36] 상속보다는 컴포지션을 사용하라

- 상속은 'is-a' 관계의 객체 계층 구조를 만들기 위해 설계 되었다. 따라서 단순하게 코드 추출 또는 재사용을 위해 상속을 사용하려고 한다면, 조금 더 신중하게 생각해야 한다. 
  - 일반적으로 이러한 경우에는 상속보다는 컴포지션을 사용하는 것이 좋다.
- 상속의 몇 가지 단점
  - 상속은 하나의 클래스만을 대상으로 할 수 있다.
    - 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다. 
  - 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어지고 인터페이스 분리 원칙을 위반하게 된다. 
  - 상속은 이해하기 어렵다. 개발자가 메서드를 읽고, 메서드의 작동 방식을 이해하기 위해 슈퍼 클래스를 여러 번 확인해야 한다면, 문제가 있는 것이다.
- **컴포지션을 사용한다는 것은 객체를 프로퍼티로 갖고, 함수를 호출하는 형태로 재사용하는 것을 의미한다.**
  - 객체를 다른 모든 객체에서 갖고 활용하는 추가 코드가 필요하다.
  - 하지만 이런 추가 코드로 인해서 코드를 읽는 사람들이 코드의 실행을 더 명확하게 예측할 수 있고, 컴포지션 객체를 훨씬 자유롭게 사용할 수 있다는 장점도 있다.
  - 컴포지션을 활용하면, 하나의 클래스 내부에서 여러 기능을 재사용 할 수 있게 된다.
    - 상속으로 이를 구현하려면, 두 기능을 하나의 슈퍼클래스에 배치해야 한다. 이 때문에 클래스들에 복잡한 계층 구조가 만들어질 수 있다.
    - 하지만 이것은 굉장히 나쁜 해결방법이다. 서브클래스가 필요하지도 않은 기능을 갖고, 단순하게 이를 차단할 뿐이다. 
- 모든 것을 가져올 수밖에 없는 상속
  - 상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져온다.
  - 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구이지만 일부분을 재사용하기 위한 목적으로는 적합하지 않다.
  - 일부분만 재사용하고 싶다면, 컴포지션을 사용하는 것이 좋다. 컴포지션은 우리가 원하는 행위만 가져올 수 있기 때문이다.
- 캡슐화를 깨는 상속
  - 상속을 잘못 활용하면 내부적인 구현 방법 변경에 의해서 클래스의 캡슐화가 깨질 수 있다.
  - 컴포지션을 사용하면 다형성이 사라질 수 있는데, 만약 이를 유지하고 싶다면 위임 패턴을 사용할 수 있다.
    - 위임 패턴은 클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현하는 패턴이다.
    - 이렇게 구현된 메서드를 포워딩 메서드라고 부른다.
    - 코틀린은 위임 패턴을 쉽게 구현할 수 있는 문법을 제공한다.
- 오버라이딩 제한하기
  - 상속은 허용하지만, 메서드는 오버라이드 하지 못하게 만들때는 open 키워드를 사용한다. open 클래스는 open 메서드만 오버랑드 할 수 있다.
  - 메서드를 오버라이드할 때, 서브클래스에서 해당 메서드에 final 을 붙일 수 있다.
- 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정하지 않아도 되는데 이것은 덜 명시적이고, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험하다.
- 그렇다면 상속은 언제 사용하면 좋을까?
  - 명확한 'is-a 관계' 일 때 
  - 슈퍼클래스를 상속하는 모든 서브클래스는 슈퍼클래스로 동작할 수 있어야 한다.
  - 슈퍼클래스의 모든 단위 테스트는 서브클래스도 통과할 수 있어야 한다.(리스코프 치환 원칙)
- 상속을 위해 설계되지 않은 메서드는 final 로 만들어 두는 것이 좋다.

**궁금**
결론은 Class를 하나 더 만들어서 사용하는거 아닌가?

<br>
<br>
<hr>
<br>
<br>

### [아이템37] 데이터 집합 표현에 data 한정자를 사용하라

- data 한정자를 붙이면, 다음과 같은 몇 가지 함수가 자동으로 생성된다. 

  - toString
  - equals 와 hashCode
  - copy
  - componentN(component1, component2 등)

- toString: 클래스의 이름과 기본 생성자 형태로 모든 프로퍼티와 값을 출력해준다. 로그 출력할 때나 디버그할 때 유용하다.

- equals: 기본 생성자의 프로퍼티가 같은지 확인해 준다. 그리고 hashCode 는 equals 와 같은 결과를 나타낸다.

- copy

  - immutable 데이터 클래스를 만들 때 편리하다.

  - copy 는 기본 생성자 프로퍼티가 같은 새로운 객체를 복제한다. 새로 만들어진 객체의 값은 이름있는 아규먼트를 활용해서 변경할 수 있다.

    - ~~~kotlin
      val newObj = player.copy(name = "Thor")
      print(newObj) // Player(id=0, name=Thor, points=9999)
      ~~~

  - copy 메서드는 객체를 얕은 복사하지만, 이것은 객체가 immutable 이라면 상관이 없다. immutable 객체는 깊은 복사한 객체가 필요 없기 때문이다.

- componentN 

  - 위치를 기반으로 객체를 해제할 수 있게 해준다.

  - ~~~kotlin
    val player = Player(0, "Gecko", 9999)
    val id: Int = player.component1()
    val name: String = player.component2()
    val pts = player.component3()
    ~~~

  - componentN 함수만 있다면, List 와 Map.Entry 등의 원하는 형태로도 객체를 해제할 수 있다.

  - 객체를 해제할 때는 주의해야 하므로 데이터 클래스의 기본 생성자에 붙어 있는 프로퍼티 이름과 같은 이름을 사용하는 것이 좋다.

    - 그렇게 하면 순서등을 잘못 지정했을 때, 인텔리제이와 안드로이드 스튜디오가 관련된 경고를 준다.

  - 값을 하나만 갖는 데이터 클래스는 해제하지 않도록 하자.

    - ~~~kotlin
      val (name) = User("John") // 이렇게 쓰지 말자
      val user = User("John")
      user.let { (a) -> print(A) } // 이렇게 쓰지 말자
      ~~~

- 튜플 대신 데이터 클래스 사용하기

  - 데이터 클래스는 듀플보다 많은 것을 제공한다.
  - 코틀린의 튜플은 Serializable 을 기반으로 만들어지며, toString 을 사용할 수 있는 제네릭 데이터 클래스이다.
  - Pair 와 Triple 이 코틀린에 남아 있는 마지막 튜플이다. 
    - 과거에는 더 많은 튜플을 정의할 수 있었다. 그러나 튜플은 데이터 클래스와 같은 역할을 하면서, 훨씬 가독성이 나쁘다.  그래서 점차 없어진 것이다.
    - 튜플만 보고는 어떤 타입을 나타내는지 예측할 수 없다.
  - 값에 간단하게 이름을 붙이거나, 미리 알 수 없는 aggregate(집합)를 표현하는 경우에나 사용한다.
  - 튜플 대신 데이터 클래스를 사용하는 이점 
    - 함수의 리턴 타입이 더 명확해진다.
    - 리턴 타입이 더 짧아지며, 전달하기 쉬워진다.
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면, 경고가 출력된다.

**추가내용**
다음과 같이 구조 분해 할당을 하면 될 것 같다.
`val (name, description, _) = Triple("a","b","c")`

<br>
<br>
<hr>
<br>
<br>

### [아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라

- SAM(Single-Abstract Method): 메서드가 하나만 있는 인터페이스

  - ~~~kotlin
    interface OnClick {
        fun clicked(view: View)
    }
    ~~~

- 함수가 SAM 을 받는다면, 이러한 인터페이스를 구현한 객체를 전달받는다는 의미이다.

- 파라미터를 전달하는 다양한 방법들 

  - 람다 표현식 또는 익명 함수로 전달

    - ~~~kotlin
      setOnclickListener { /*...*/ }
      setOnclickListener(fun(view) { /*...*/ })
      ~~~

  - 함수 레퍼런스 또는 제한된 함수 레퍼런스 전달

    - ~~~kotlin
      setOnclickListener(::println)
      setOnclickListener(this::showUsers)
      ~~~

  - 선언된 함수 타입을 구현한 객체로 전달

    - ~~~kotlin
      class ClickListener: (View)->Unit {
          override fun invoke(view: View) {
              // ...
          } 
      }
      setOnClickListener(ClickListener())
      ~~~

- SAM 의 장점은 '그 아규먼트에 이름이 붙어 있는 것' 이라고 말하는 사람들도 있지만, 타입 별칭(type aliase)을 사용하면, 함수 타입도 이름을 붙일 수 있다.

  - ~~~kotlin
    typealias OnClick = (View) -> Unit
    ~~~

- 람다 표현식을 사용할 때는 아규먼트 분해(destructure argument)도 사용 할 수 있다.

- **인터페이스를 사용해야 하는 특별한 이유가 없다면, 함수 타입을 활용하는게 좋다.**

- 언제 SAM 을 사용해야 할까?

  - 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계 할때 사용.
  - 자바에서는 인터페이스가 더 명확하다.
  - 함수 타입으로 만들어진 클래스는 자바에서 타입 별칭과 IDE 의 지원등을 제대로 받을 수 없다.

<br>
<br>
<hr>
<br>
<br>

### [아이템39] 태그 클래스보다는 클래스 계층을 사용하라

- 상수(constant) 모드를 태그(tag)라고 부르며, 태그를 포함한 클래스를 태그 클래스(tagged class)라고 부른다.
- 태그 클래스의 문제점
  - 서로 다른 책임을 한 클래스에 태그로 구분해서 넣는다.
  - 한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가 된다.
  - 여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있으며, 더 많은 프로퍼티가 필요하다.
  - 요소가 여러 목적을 가지고, 요소를 여러 방법으로 설정할 수 있는 경우에는 상태의 일관성과 정확성을 지키기 어렵다.
  - 팩토리 메서드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 굉장히 어렵다.
- 코틀른은 그래서 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용한다.
  - 한 클래스에 여러 모드를 만드는 방법 대신에, 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.
  - 이러한 클래스에는 sealed 한정자를 붙여서 서브클래스 정의를 제한한다.
- sealed 한정자
  - abstract 한정자를 사용할 수도 있지만, sealed 한정자는 외부 파일에서 서브 클래스를 만드는 행위 자체를 모두 제한한다.
  - 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을 거라는게 보장된다. 
  - 따라서 when 을 사용할 때 else 브랜치를 따로 만들 필요가 없다.
  - sealed 한정자를 사용하면, 확장 함수를 사용해서 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경을 쉽게 처리할 수 있다.
  - 클래스의 서브 클래스를 제어하려면, sealed 한정자를 사용해야 한다. 
  - abstract 는 상속과 관련된 설계를 할 때 사용한다.
- 태그 클래스와 상태 패턴의 차이
  - 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.
  - 상태 패턴은 프론트엔드 컨트롤러, 프레젠터(presenter), 뷰모델을 설계할 때 많이 사용된다.
  - 상태는 더 많은 책임을 가진 클래스이며, 상태는 변경할 수 있다.
  - 구체 상태는 객체를 활용해서 표현하는 것이 일반적이며, 태크 클래스보다는 sealed 클래스 계층으로 만들도록 하자.
  - 또한 이를 immutable 객체로 만들고, 변경해야 할 때마다 state 프로퍼티를 변경하게 만들자.
