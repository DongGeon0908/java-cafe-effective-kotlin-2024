# Week 8

## 목차

- 아이템 33: 생성자 대신 팩토리 함수를 사용하라
- 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라
- 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 만들어라

<br>
<hr>
<br>

### 아이템 33: 생성자 대신 팩토리 함수를 사용하라

> 생성자의 역할을 대신 해 주는 함수를 **팩토리 함수**라고 부른다.

<br>

**팩토리 함수를 사용하면 좋은 점들**
- 생성자와 다르게, 함수에 이름을 붙일 수 있다. 또한 동일한 파라미터 타입을 갖는 생성자의 충돌을 줄일 수 있다.
- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다. 따라서 다른 객체를 생성할 때 사용할 수 있다.
  - 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용하게 사용할 수 있다.
- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없다.
  - 싱글턴 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위해 캐싱 메커니즘을 사용할 수도 있다.
- 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있다.
  - 이를 활용하면 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있다.
- 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있다.
- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified 로 만들 수 있다.
  - reified 키워드는 이 타입 파라미터가 실행 시점에 지워지지 않음을 표시한다.
- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있다.
- 생성자는 즉시 슈퍼클래스 또는 기본 생성자를 호출해야 한다. 하지만 팩토리 함수를 사용하면, 원하는 때에 생성자를 호출할 수 있다.
- 서브 클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에 팩토리 함수로 서브클래스를 만들어 낼 수는 없다.

<br>

**companion 객체 팩토리 함수**

- 인터페이스에도 companion object 를 이용해 팩토리 함수를 구현할 수 있다.

<br>

**팩토리 함수에서 많이 사용하는 이름들**
- **from**
  - 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수를 나타낸다.
  - ~~~kotlin
     val date: Date = Date.from(instant)
    ~~~
- **of**
  - 파라미터를 여러 개 받고, 이를 통합해서 인스턴스를 만들어 주는 함수를 나타낸다.
  - ~~~kotlin
     val faceCards: Set<Rank> = EnumSet.of(JACK, QUEEN, KING)
    ~~~
- **valueOf**
  - from 또는 of 와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수
  - ~~~kotlin
     val prime: BigInteger = BigInteger.valueOf(Integer.MAX_VALUE)
    ~~~
- **instance 또는 getInstance**
  - 싱글턴으로 인스턴스 하나를 리턴하는 함수
  - 파라미터가 있을 경우, 아규먼트를 기반으로 하는 인스턴스를 리턴한다.
  - 일반적으로 같은 아규먼트를 넣으면, 같은 인스턴스를 리턴하는 형태로 작동한다.
  - ~~~kotlin
     val luke: StackWalker = StackWalker.getInstance(options)
    ~~~
- **createInstance 또는 newInstance**
  - getInstance 처럼 동작하지만, 싱글턴이 적용되지 않아서, 함수를 호출할 때마다 새로운 인스턴스를 만들어서 리턴한다.
  - ~~~kotlin
     val newArray = Array.newInstance(classObject, arrayLen)
    ~~~
- **getType**
  - getInstance 처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름이다. 
  - 타입은 팩토리 함수에서 리턴하는 타입이다.
  - ~~~kotlin
     val fs: FileStore = Files.getFileStore(path)
    ~~~

<br>

**companion 객체는 인터페이스를 구현할 수 있으며, 클래스를 상속받을 수도 있다.**
> 추상 companion 객체 팩토리는 값을 가질 수 있다. 따라서 캐싱을 구현하거나, 테스트를 위한 가짜 객체 생성을 할 수 있다.

- **확장 팩토리 함수**

  - 이미 companion 객체가 존재할 때, 이 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때, companion 객체를 직접 수정할 수 없다면 확장 함수를 활용하자.
  - 확장 팩토리 함수를 이용하면, 외부 라이브러리를 확장할 수 있다. 다만 companion 객체를 확장하려면, (적어도 비어 있는) 컴패니언 객체가 필요하다.

- **톱레벨 팩토리 함수**

  - 대표적으로 listOf, setOf, mapOf 가 있다.
  - 톱레벨 함수를 만들 때는 꼭 이름을 신중하게 생각해서 잘 지정해야 한다.

- **가짜 생성자**

  - 인터페이스를 위한 생성자를 만들고 싶을 때 사용
  - reified 타입 아규먼트를 갖게 하고 싶을 때 사용
  - invoke 연산자를 갖는 companion 객체를 사용하면, 비슷한 결과를 사용할 수 있지만 추천하지 않는 방법이다.

- **팩토리 클래스의 메서드**

  - 점층적 생성자 패턴과 빌더 패턴은 코틀린에서는 의미가 없다.(아이템34 참고)
  - 팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 다양한 기능을 갖는다.
  - 팩토리 클래스는 프로퍼티를 가질 수 있기 때문에, 이를 활용하면 다양한 종류로 최적화하고, 다양한 기능을 도입할 수 있다.(캐싱, 이전에 만든 객체를 복제해서 객체 생성 등등)


<br>
<hr>
<br>


### 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라

- 디폴트 아규먼트가 점층적 생성자보다 좋은 이유
  - 파라미터들의 값을 워하는 대로 지정할 수 있따.
  - 아규먼트를 원하는 순서로 지정할 수 있다.
  - 명시적으로 이름을 붙여서 아규먼트를 지정하므로 의미가 훨씬 명확하다.

<br>
  
- 빌더 패턴보다 이름 있는 파라미터를 사용하는 것이 좋은 이유
  - 더 짧다.
  - 더 명확하다. 거대하게 빌더 패턴으로 만들어진 객체는 디폴트로 어떤 값을 가지는지, 그리고 내부적으로 어떤 추가적인 처리가 일어나는지 이해하기 어렵다.
  - 더 사용하기 쉽다. 기본 생성자는 기본적으로 언어에 내장된 개념이지만, 빌터 패턴은 언어 위에 추가로 구현한 개념이므로, 추가적인 knowledge 가 필요하다.
  - **동시성과 관련된 문제가 없다. 코틀린의 함수 파라미터는 항상 immutable 이다. 반면 대부분의 빌더 패턴에서 프로퍼티는 mutable 이다.
    따라서 빌더 패턴의 빌더 함수를 thread-safe 하게 구현하는 것은 어렵다.**

<br>
  
- 코틀린에서는 빌더 패턴을 거의 사용하지 않는다. 빌더 패턴은 다음과 같은 경우에만 사용한다.
  - 빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때
  - 디폴트 아규먼트와 DSL 을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API 를 설계할 때
 
<br>

- **위의 2가지를 제외하면, 빌더 패턴 대신에 디폴트 아규먼트를 갖는 기본 생성자 또는 DSL 을 사용하는 것이 좋다.**


<br>
<hr>
<br>


### 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 만들어라

> 코틀린의 DSL 은 type-safe 이므로, 여러 가지 유용한 힌트를 활용할 수 있다.

**사용자 정의 DSL 만들기**

- 함수 타입은 함수로 사용 할 수 있는 객체를 나타내는 타입이다.

- 함수 타입의 몇가지 예

```
    - ()->Unit: 아규먼트를 갖지 않고, Unit 을 리턴하는 함수
    - (Int)->Unit: Int 를 아규먼트로 받고, Unit 을 리턴하는 함수
    - (Int)->Int: Int 를 아규먼트로 받고, Int 를 리턴하는 함수
    - (Int, Int)->Int: Int 2개를 아규먼트로 받고, Int 를 리턴하는 함수
    - (Int)->()->Unit: Int 를 아규먼트로 받고, 다른 함수를 리턴하는 함수. 이때 다른 함수는 아규먼트로 아무것도 받지 않고, Unit 을 리턴
    - (()->Unit)->Unit: 다른 함수를 아규먼트로 받고, Unit 을 리턴하는 함수. 이때 다른 함수는 아규먼트로 아무것도 받지 않고, Unit 을 리턴
```

<br>

**함수 타입을 만드는 기본적인 방법**
- 람다 표현식
- 익명 함수
- 함수 레퍼런스

<br>

**리시버를 가진 함수 타입**

- 확장 함수를 나타내는 특별한 타입
- 일반적인 함수 타입과 비슷 하지만, 파라미터 앞에 리시버 타입이 추가되어 있으며, 점(.) 기호로 구분되어 있다.
- ~~~kotlin
      val myPlus = fun Int.(other: Int) = this + other
  ~~~
- 함수는 람다식, 구체적으로 리시버를 가진 람다 표현식을 사용해서 정의 할 수 있다. 이렇게 하면 스코프 내부에 this 키워드가 확장 리시버를 참조하게 된다.
- ~~~kotlin
      val myPlus: Int.(Int)->Int = { this + it }
  ~~~

<br>

**리시버를 가진 함수 타입의 가장 중요한 특징은 this 의 참조 대상을 변경할 수 있다는 것이다.**

**this 는 apply 함수에서 리시버 객체의 메서드와 프로퍼티를 간단하게 참조할 수 있게 해주기도 한다.**

<br>

**DSL 은 언제 사용해야 할까?**
- 복잡한 자료 구조
- 계층적인 구조
- 거대한 양의 데이터
- 많이 사용되는 반복되는 코드(코드를 읽는 사람에게 크게 중요하지 않은 정보를 포함하는 반복되는 코드)가 있고, 이를 간단하게 만들 수 있는 별도의
    코틀린 기능이 없다면, DSL 사용을 고려해 보는 것이 좋다.
